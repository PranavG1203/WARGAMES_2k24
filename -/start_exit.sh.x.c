#if 0
	shc Version 4.0.3, Generic Shell Script Compiler
	GNU GPL Version 3 Md Jahidul Hamid <jahidulhamid@yahoo.com>

	shc -f start_exit.sh 
#endif

static  char data [] = 
#define      tst1_z	22
#define      tst1	((&data[2]))
	"\055\345\152\046\270\017\202\141\256\217\226\240\130\111\367\034"
	"\147\276\215\123\317\316\022\112\102\241\112"
#define      text_z	1440
#define      text	((&data[168]))
	"\202\356\071\207\174\253\137\317\126\006\173\215\165\022\144\100"
	"\027\154\124\063\362\313\306\037\261\011\301\374\335\046\332\140"
	"\024\023\347\221\277\106\141\025\115\335\243\302\357\007\002\007"
	"\164\127\072\146\042\001\206\324\013\107\320\351\155\252\111\202"
	"\276\060\024\175\167\165\223\305\122\067\207\102\077\211\111\263"
	"\340\204\032\003\206\240\330\222\350\250\173\126\123\304\330\022"
	"\365\354\220\155\142\043\062\265\133\271\370\232\103\102\115\044"
	"\306\147\050\115\010\000\337\360\250\133\106\374\040\037\016\026"
	"\014\237\203\156\303\266\044\036\160\034\270\263\136\125\332\062"
	"\236\233\017\206\307\272\071\147\063\315\261\150\054\275\016\360"
	"\140\141\201\256\206\133\022\103\077\115\234\122\343\163\036\121"
	"\211\322\267\271\331\343\164\036\063\005\320\150\335\250\321\133"
	"\056\321\167\300\366\333\371\377\301\003\124\370\034\240\213\165"
	"\271\167\300\316\302\352\377\205\106\316\106\267\110\100\221\107"
	"\336\310\277\033\106\015\106\162\271\034\167\241\253\323\175\266"
	"\205\151\161\302\057\245\364\137\376\203\243\167\042\125\322\112"
	"\221\323\122\033\044\076\201\116\115\270\224\167\305\100\060\045"
	"\330\013\341\031\002\225\377\065\175\301\162\001\055\357\252\060"
	"\124\151\314\354\372\217\246\236\361\043\131\006\311\210\211\036"
	"\063\177\055\026\223\271\247\164\342\370\141\005\256\075\345\355"
	"\161\275\016\257\036\173\231\136\274\220\003\040\013\302\151\044"
	"\350\226\354\012\210\071\211\312\033\175\221\000\372\225\343\155"
	"\106\373\166\015\260\052\146\063\114\253\052\177\307\200\222\002"
	"\272\246\230\102\004\122\271\047\325\274\373\326\335\321\027\054"
	"\075\237\353\200\346\146\057\152\131\162\200\227\341\017\353\105"
	"\277\055\123\015\252\365\346\264\024\112\102\147\327\360\123\147"
	"\206\252\220\236\214\045\300\176\253\323\345\220\270\267\021\242"
	"\034\022\260\350\125\214\156\031\011\046\076\100\343\135\336\147"
	"\313\323\340\357\222\130\005\153\323\126\344\133\110\041\351\274"
	"\205\064\301\273\054\326\314\330\075\163\362\032\054\175\270\060"
	"\107\340\251\116\321\157\276\363\316\075\061\236\325\150\371\161"
	"\200\063\321\057\226\106\236\132\116\272\347\127\363\231\264\245"
	"\210\344\205\326\017\020\052\034\200\301\160\165\076\344\315\320"
	"\130\313\102\037\321\257\306\007\235\227\017\226\136\374\155\045"
	"\165\321\230\176\162\063\267\120\242\115\315\301\152\266\046\147"
	"\360\354\046\264\122\227\017\266\035\145\042\350\215\340\327\027"
	"\242\245\104\006\315\051\116\057\177\354\314\335\003\223\160\141"
	"\360\246\253\042\151\255\166\073\036\362\175\140\254\370\326\133"
	"\320\113\053\334\217\022\107\217\376\370\341\051\317\221\021\131"
	"\055\221\117\303\064\156\342\027\255\323\161\253\105\033\263\134"
	"\312\244\260\003\136\102\215\360\053\026\277\342\040\146\003\124"
	"\317\226\343\206\101\223\164\107\031\155\213\330\003\130\207\166"
	"\157\214\373\072\246\376\352\266\346\360\033\043\213\102\251\062"
	"\303\002\301\003\331\032\033\306\056\233\027\021\351\003\326\100"
	"\273\233\354\170\256\304\302\067\114\110\337\153\066\043\217\300"
	"\214\331\301\275\374\207\067\073\262\007\160\203\377\134\157\323"
	"\102\314\331\153\114\026\240\313\037\136\171\223\235\216\006\014"
	"\231\274\344\373\146\152\302\157\215\001\053\176\022\336\024\036"
	"\150\240\050\023\010\261\310\357\110\065\015\203\075\203\334\146"
	"\231\266\347\012\163\010\114\054\165\246\376\043\113\162\246\026"
	"\066\031\321\072\235\123\075\160\336\035\006\167\267\132\231\053"
	"\134\003\270\021\262\363\226\271\123\207\136\331\374\032\052\230"
	"\140\104\361\112\142\124\366\237\116\271\002\372\174\310\346\324"
	"\341\140\234\255\327\115\072\001\312\044\026\060\157\052\010\312"
	"\262\015\155\343\162\377\072\351\225\230\305\160\176\075\171\200"
	"\233\223\053\162\236\250\000\320\246\036\200\145\123\174\137\275"
	"\336\113\333\102\360\346\272\200\251\312\331\356\173\334\256\022"
	"\051\214\141\223\065\321\164\055\052\142\357\204\030\065\357\000"
	"\062\175\325\162\346\100\363\034\222\061\102\222\346\301\275\066"
	"\376\054\157\242\124\311\026\322\371\141\103\303\053\217\365\167"
	"\353\340\263\157\214\226\213\146\152\161\246\322\256\371\077\040"
	"\063\061\131\006\353\047\340\227\227\272\026\073\111\145\103\076"
	"\207\257\306\323\267\356\132\103\315\055\261\322\102\137\305\046"
	"\222\257\050\277\035\042\030\246\007\063\303\036\377\224\237\042"
	"\340\025\327\135\247\176\240\200\040\235\065\120\102\100\034\351"
	"\213\240\172\153\255\202\333\321\236\025\330\204\326\342\245\274"
	"\350\317\220\365\217\261\113\144\242\175\017\107\256\065\073\166"
	"\274\221\011\173\051\232\350\226\306\173\321\056\047\336\151\022"
	"\145\107\225\206\076\175\341\172\365\214\363\362\322\140\042\021"
	"\301\345\147\226\344\257\213\257\147\053\265\015\102\144\055\155"
	"\144\046\253\126\156\036\006\303\213\356\263\361\016\070\277\003"
	"\231\262\245\020\265\107\251\014\006\331\032\021\104\242\126\253"
	"\300\165\251\352\001\360\075\060\220\205\326\104\123\036\033\044"
	"\145\170\363\274\161\172\332\221\003\073\072\146\106\061\160\251"
	"\072\077\251\131\331\026\105\004\011\272\357\106\270\113\301\267"
	"\365\343\336\261\211\346\111\172\134\313\121\010\063\210\232\343"
	"\053\214\045\321\014\054\075\247\201\113\055\074\123\153\214\064"
	"\050\135\203\223\054\147\166\046\341\055\153\172\170\133\044\372"
	"\023\152\211\140\235\001\205\124\200\126\216\354\206\011\372\273"
	"\142\261\247\366\276\112\346\163\176\206\342\065\066\062\277\154"
	"\115\011\214\240\114\374\325\303\344\160\265\051\256\045\310\272"
	"\076\153\350\353\276\237\030\200\163\260\252\356\146\262\277\330"
	"\170\102\122\216\351\321\165\366\201\252\312\117\133\144\155\013"
	"\004\061\122\223\351\175\004\215\130\176\311\210\203\207\214\134"
	"\274\102\266\262\066\255\357\264\262\266\352\005\365\007\202\025"
	"\367\070\005\273\266\326\005\136\044\362\117\277\352\103\136\063"
	"\113\130\103\234\302\255\055\055\360\066\333\012\022\155\274\346"
	"\344\164\324\155\227\324\246\324\171\060\265\117\044\113\075\356"
	"\000\366\114\254\241\261\347\365\213\025\003\346\320\265\117\334"
	"\267\255\033\056\152\054\337\233\230\062\204\022\212\015\144\102"
	"\051\307\162\305\301\242\276\037\162\337\026\066\215\235\023\373"
	"\120\363\236\223\253\161\333\076\002\153\302\332\222\024\123\235"
	"\352\011\331\167\072\235\321\101\335\032\066\035\267\352\374\000"
	"\040\225\116\300\253\011\271\003\321\124\232\346\132\254\117\075"
	"\171\262\045\142\037\354\051\143\323\362\200\106\272\021\227\140"
	"\057\013\265\017\247\051\143\066\350\011\222\331\325\102\035\235"
	"\161\314\120\207\034\153\250\121\313\266\074\073\157\262\052\306"
	"\323\011\002\245\011\033\146\321\340\270\157\075\167\365\235\041"
	"\013\373\130\222\101\331\246\037\005\306\026\365\173\005\330\045"
	"\155\000\163\165\000\123\145\251\256\254\246\317\313\264\345\327"
	"\124\150\105\027\037\151\065\217\206\355\102\345\363\032\012\141"
	"\033\175\327\033\321\074\305\200\350\153\117\264\040\064\213\164"
	"\235\321\213\274\073\301\113\301\257\216\246\243\251\261\004\304"
	"\057\333\340\000\030\245\200\001\021\317\265\061\004\101\246\241"
	"\022\062\135\115\363\251\016\243\067\265\106\340\146\113\244\225"
	"\047\204\225\077\052\025\101\073\345\366\155\351\067\024\213\111"
	"\106\350\227\072\221\245\335\310\132\044\251\301\157\115\126\226"
	"\322\353\326\375\001\027\070\347\015\246\321\105\272\134\217\001"
	"\105\046\073\326\314\031\237\047\075\111\350\254\226\076\103\151"
	"\052\031\146\054\060\237\023\076\105\344\204\000\101\023\002\206"
	"\072\076\135\007\127\374\057\225\106\027\102\334\126\205\106\200"
	"\236\254\255\317\114\301\015\221\245\221\222\347\245\224\155\340"
	"\323\312\350\052\307\027\277\015\056\001\352\205\207\060\006\046"
	"\335\263\365\051\164\002\273\032\224\116\001\072\343\157\033\266"
	"\071\003\341\001\032\240\016\111\242\371\316\052\052\325\120\007"
	"\210\105\061\375\110\354\027\334\072\031\027\036\210\062\324\302"
	"\065\265\303\120\126\322\231\371\313\150\043\365\075\164\375\306"
	"\271\056\303\001\033\333\336\126\364\365\164\174\050\111\076\135"
	"\376\002\255\125\324\107"
#define      inlo_z	3
#define      inlo	((&data[1921]))
	"\272\326\122"
#define      lsto_z	1
#define      lsto	((&data[1924]))
	"\201"
#define      tst2_z	19
#define      tst2	((&data[1927]))
	"\240\302\013\223\301\322\353\201\146\040\316\070\326\131\037\120"
	"\356\035\256\142\021\167\242\336"
#define      xecc_z	15
#define      xecc	((&data[1951]))
	"\107\166\121\146\364\047\100\043\365\322\267\311\222\114\236\030"
	"\061"
#define      msg2_z	19
#define      msg2	((&data[1969]))
	"\362\003\374\107\120\332\255\322\073\004\064\263\236\361\251\316"
	"\324\213\315\321\173\250\361\005\252"
#define      chk1_z	22
#define      chk1	((&data[1996]))
	"\225\172\241\007\020\227\223\074\316\063\377\222\222\166\252\322"
	"\115\215\053\110\151\322\137\051\070\121\101\217\356\244\103\216"
#define      rlax_z	1
#define      rlax	((&data[2023]))
	"\243"
#define      opts_z	1
#define      opts	((&data[2024]))
	"\071"
#define      chk2_z	19
#define      chk2	((&data[2026]))
	"\043\313\205\313\355\113\110\011\131\136\073\305\324\163\305\341"
	"\241\341\121\271"
#define      msg1_z	65
#define      msg1	((&data[2058]))
	"\035\302\007\043\154\116\375\136\343\170\377\353\210\143\113\134"
	"\152\150\357\046\033\074\000\211\165\377\365\235\250\356\342\270"
	"\253\343\066\130\116\263\071\150\062\037\001\264\317\172\154\276"
	"\160\151\257\351\237\360\363\343\311\177\233\131\072\253\032\214"
	"\056\350\336\351\252\035\320\331\243\317\005\164\021\155\217"
#define      pswd_z	256
#define      pswd	((&data[2135]))
	"\150\224\216\230\332\235\111\125\363\161\171\131\147\130\127\330"
	"\262\214\365\042\347\037\375\315\152\373\247\316\226\133\035\267"
	"\307\214\062\364\252\213\345\336\125\016\070\275\146\217\225\031"
	"\034\213\074\004\252\071\321\024\065\171\343\314\324\000\203\233"
	"\214\265\220\067\100\165\026\226\204\116\123\353\336\351\004\372"
	"\165\100\376\040\172\320\064\257\112\030\173\036\030\376\272\245"
	"\264\112\335\364\300\363\213\104\102\337\057\041\310\064\034\076"
	"\164\033\136\357\354\223\236\066\253\031\125\304\030\017\151\314"
	"\132\107\301\032\073\114\136\175\053\216\237\364\302\273\062\067"
	"\326\220\046\302\043\304\371\317\336\116\223\367\136\374\303\270"
	"\104\205\322\177\322\060\374\375\276\233\362\201\127\045\270\056"
	"\265\336\361\331\243\352\250\201\071\073\170\227\070\074\117\174"
	"\301\042\373\223\123\370\221\022\224\204\223\354\251\113\032\137"
	"\051\013\070\314\366\341\116\057\035\307\306\126\003\026\323\305"
	"\071\316\130\214\307\352\236\134\156\062\110\027\175\143\166\247"
	"\156\257\164\144\221\302\224\256\212\133\004\215\161\327\123\253"
	"\246\254\067\156\226\326\313\004\010\024\034\015\070\217\053\372"
	"\227\116\147\345\114\305\311\304\305\264\115\125\215\172\050\366"
	"\017\267\216\352\124\330\077\107\112\270\125\202\110\200\175\337"
	"\317\344\305\033\252\216\337\160\103\055\305\320\247\355\306\267"
#define      date_z	1
#define      date	((&data[2444]))
	"\321"
#define      shll_z	10
#define      shll	((&data[2445]))
	"\367\251\146\334\363\114\060\240\156\172\101\170"/* End of data[] */;
#define      hide_z	4096
#define SETUID 0	/* Define as 1 to call setuid(0) at start of script */
#define DEBUGEXEC	0	/* Define as 1 to debug execvp calls */
#define TRACEABLE	1	/* Define as 1 to enable ptrace the executable */
#define HARDENING	0	/* Define as 1 to disable ptrace/dump the executable */
#define BUSYBOXON	0	/* Define as 1 to enable work with busybox */

#if HARDENING
static const char * shc_x[] = {
"/*",
" * Copyright 2019 - Intika <intika@librefox.org>",
" * Replace ******** with secret read from fd 21",
" * Also change arguments location of sub commands (sh script commands)",
" * gcc -Wall -fpic -shared -o shc_secret.so shc_secret.c -ldl",
" */",
"",
"#define _GNU_SOURCE /* needed to get RTLD_NEXT defined in dlfcn.h */",
"#define PLACEHOLDER \"********\"",
"#include <dlfcn.h>",
"#include <stdlib.h>",
"#include <string.h>",
"#include <unistd.h>",
"#include <stdio.h>",
"#include <signal.h>",
"",
"static char secret[128000]; //max size",
"typedef int (*pfi)(int, char **, char **);",
"static pfi real_main;",
"",
"// copy argv to new location",
"char **copyargs(int argc, char** argv){",
"    char **newargv = malloc((argc+1)*sizeof(*argv));",
"    char *from,*to;",
"    int i,len;",
"",
"    for(i = 0; i<argc; i++){",
"        from = argv[i];",
"        len = strlen(from)+1;",
"        to = malloc(len);",
"        memcpy(to,from,len);",
"        // zap old argv space",
"        memset(from,'\\0',len);",
"        newargv[i] = to;",
"        argv[i] = 0;",
"    }",
"    newargv[argc] = 0;",
"    return newargv;",
"}",
"",
"static int mymain(int argc, char** argv, char** env) {",
"    //fprintf(stderr, \"Inject main argc = %d\\n\", argc);",
"    return real_main(argc, copyargs(argc,argv), env);",
"}",
"",
"int __libc_start_main(int (*main) (int, char**, char**),",
"                      int argc,",
"                      char **argv,",
"                      void (*init) (void),",
"                      void (*fini)(void),",
"                      void (*rtld_fini)(void),",
"                      void (*stack_end)){",
"    static int (*real___libc_start_main)() = NULL;",
"    int n;",
"",
"    if (!real___libc_start_main) {",
"        real___libc_start_main = dlsym(RTLD_NEXT, \"__libc_start_main\");",
"        if (!real___libc_start_main) abort();",
"    }",
"",
"    n = read(21, secret, sizeof(secret));",
"    if (n > 0) {",
"      int i;",
"",
"    if (secret[n - 1] == '\\n') secret[--n] = '\\0';",
"    for (i = 1; i < argc; i++)",
"        if (strcmp(argv[i], PLACEHOLDER) == 0)",
"          argv[i] = secret;",
"    }",
"",
"    real_main = main;",
"",
"    return real___libc_start_main(mymain, argc, argv, init, fini, rtld_fini, stack_end);",
"}",
"",
0};
#endif /* HARDENING */

/* rtc.c */

#include <sys/stat.h>
#include <sys/types.h>

#include <errno.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <unistd.h>

/* 'Alleged RC4' */

static unsigned char stte[256], indx, jndx, kndx;

/*
 * Reset arc4 stte. 
 */
void stte_0(void)
{
	indx = jndx = kndx = 0;
	do {
		stte[indx] = indx;
	} while (++indx);
}

/*
 * Set key. Can be used more than once. 
 */
void key(void * str, int len)
{
	unsigned char tmp, * ptr = (unsigned char *)str;
	while (len > 0) {
		do {
			tmp = stte[indx];
			kndx += tmp;
			kndx += ptr[(int)indx % len];
			stte[indx] = stte[kndx];
			stte[kndx] = tmp;
		} while (++indx);
		ptr += 256;
		len -= 256;
	}
}

/*
 * Crypt data. 
 */
void arc4(void * str, int len)
{
	unsigned char tmp, * ptr = (unsigned char *)str;
	while (len > 0) {
		indx++;
		tmp = stte[indx];
		jndx += tmp;
		stte[indx] = stte[jndx];
		stte[jndx] = tmp;
		tmp += stte[indx];
		*ptr ^= stte[tmp];
		ptr++;
		len--;
	}
}

/* End of ARC4 */

#if HARDENING

#include <sys/ptrace.h>
#include <sys/wait.h>
#include <signal.h>
#include <sys/prctl.h>
#define PR_SET_PTRACER 0x59616d61

/* Seccomp Sandboxing Init */
#include <stdlib.h>
#include <stdio.h>
#include <stddef.h>
#include <string.h>
#include <unistd.h>
#include <errno.h>

#include <sys/types.h>
#include <sys/prctl.h>
#include <sys/syscall.h>
#include <sys/socket.h>

#include <linux/filter.h>
#include <linux/seccomp.h>
#include <linux/audit.h>

#define ArchField offsetof(struct seccomp_data, arch)

#define Allow(syscall) \
    BPF_JUMP(BPF_JMP+BPF_JEQ+BPF_K, SYS_##syscall, 0, 1), \
    BPF_STMT(BPF_RET+BPF_K, SECCOMP_RET_ALLOW)

struct sock_filter filter[] = {
    /* validate arch */
    BPF_STMT(BPF_LD+BPF_W+BPF_ABS, ArchField),
    BPF_JUMP( BPF_JMP+BPF_JEQ+BPF_K, AUDIT_ARCH_X86_64, 1, 0),
    BPF_STMT(BPF_RET+BPF_K, SECCOMP_RET_KILL),

    /* load syscall */
    BPF_STMT(BPF_LD+BPF_W+BPF_ABS, offsetof(struct seccomp_data, nr)),

    /* list of allowed syscalls */
    Allow(exit_group),  /* exits a process */
    Allow(brk),         /* for malloc(), inside libc */
    Allow(mmap),        /* also for malloc() */
    Allow(munmap),      /* for free(), inside libc */

    /* and if we don't match above, die */
    BPF_STMT(BPF_RET+BPF_K, SECCOMP_RET_KILL),
};
struct sock_fprog filterprog = {
    .len = sizeof(filter)/sizeof(filter[0]),
    .filter = filter
};

/* Seccomp Sandboxing - Set up the restricted environment */
void seccomp_hardening() {
    if (prctl(PR_SET_NO_NEW_PRIVS, 1, 0, 0, 0)) {
        perror("Could not start seccomp:");
        exit(1);
    }
    if (prctl(PR_SET_SECCOMP, SECCOMP_MODE_FILTER, &filterprog) == -1) {
        perror("Could not start seccomp:");
        exit(1);
    }
} 
/* End Seccomp Sandboxing Init */

void shc_x_file() {
    FILE *fp;
    int line = 0;

    if ((fp = fopen("/tmp/shc_x.c", "w")) == NULL ) {exit(1); exit(1);}
    for (line = 0; shc_x[line]; line++)	fprintf(fp, "%s\n", shc_x[line]);
    fflush(fp);fclose(fp);
}

int make() {
	char * cc, * cflags, * ldflags;
    char cmd[4096];

	cc = getenv("CC");
	if (!cc) cc = "cc";

	sprintf(cmd, "%s %s -o %s %s", cc, "-Wall -fpic -shared", "/tmp/shc_x.so", "/tmp/shc_x.c -ldl");
	if (system(cmd)) {remove("/tmp/shc_x.c"); return -1;}
	remove("/tmp/shc_x.c"); return 0;
}

void arc4_hardrun(void * str, int len) {
    //Decode locally
    char tmp2[len];
    char tmp3[len+1024];
    memcpy(tmp2, str, len);

	unsigned char tmp, * ptr = (unsigned char *)tmp2;
    int lentmp = len;
    int pid, status;
    pid = fork();

    shc_x_file();
    if (make()) {exit(1);}

    setenv("LD_PRELOAD","/tmp/shc_x.so",1);

    if(pid==0) {

        //Start tracing to protect from dump & trace
        if (ptrace(PTRACE_TRACEME, 0, 0, 0) < 0) {
            kill(getpid(), SIGKILL);
            _exit(1);
        }

        //Decode Bash
        while (len > 0) {
            indx++;
            tmp = stte[indx];
            jndx += tmp;
            stte[indx] = stte[jndx];
            stte[jndx] = tmp;
            tmp += stte[indx];
            *ptr ^= stte[tmp];
            ptr++;
            len--;
        }

        //Do the magic
        sprintf(tmp3, "%s %s", "'********' 21<<<", tmp2);

        //Exec bash script //fork execl with 'sh -c'
        system(tmp2);

        //Empty script variable
        memcpy(tmp2, str, lentmp);

        //Clean temp
        remove("/tmp/shc_x.so");

        //Sinal to detach ptrace
        ptrace(PTRACE_DETACH, 0, 0, 0);
        exit(0);
    }
    else {wait(&status);}

    /* Seccomp Sandboxing - Start */
    seccomp_hardening();

    exit(0);
}
#endif /* HARDENING */

/*
 * Key with file invariants. 
 */
int key_with_file(char * file)
{
	struct stat statf[1];
	struct stat control[1];

	if (stat(file, statf) < 0)
		return -1;

	/* Turn on stable fields */
	memset(control, 0, sizeof(control));
	control->st_ino = statf->st_ino;
	control->st_dev = statf->st_dev;
	control->st_rdev = statf->st_rdev;
	control->st_uid = statf->st_uid;
	control->st_gid = statf->st_gid;
	control->st_size = statf->st_size;
	control->st_mtime = statf->st_mtime;
	control->st_ctime = statf->st_ctime;
	key(control, sizeof(control));
	return 0;
}

#if DEBUGEXEC
void debugexec(char * sh11, int argc, char ** argv)
{
	int i;
	fprintf(stderr, "shll=%s\n", sh11 ? sh11 : "<null>");
	fprintf(stderr, "argc=%d\n", argc);
	if (!argv) {
		fprintf(stderr, "argv=<null>\n");
	} else { 
		for (i = 0; i <= argc ; i++)
			fprintf(stderr, "argv[%d]=%.60s\n", i, argv[i] ? argv[i] : "<null>");
	}
}
#endif /* DEBUGEXEC */

void rmarg(char ** argv, char * arg)
{
	for (; argv && *argv && *argv != arg; argv++);
	for (; argv && *argv; argv++)
		*argv = argv[1];
}

void chkenv_end(void);

int chkenv(int argc)
{
	char buff[512];
	unsigned long mask, m;
	int l, a, c;
	char * string;
	extern char ** environ;

	mask = (unsigned long)getpid();
	stte_0();
	 key(&chkenv, (void*)&chkenv_end - (void*)&chkenv);
	 key(&data, sizeof(data));
	 key(&mask, sizeof(mask));
	arc4(&mask, sizeof(mask));
	sprintf(buff, "x%lx", mask);
	string = getenv(buff);
#if DEBUGEXEC
	fprintf(stderr, "getenv(%s)=%s\n", buff, string ? string : "<null>");
#endif
	l = strlen(buff);
	if (!string) {
		/* 1st */
		sprintf(&buff[l], "=%lu %d", mask, argc);
		putenv(strdup(buff));
		return 0;
	}
	c = sscanf(string, "%lu %d%c", &m, &a, buff);
	if (c == 2 && m == mask) {
		/* 3rd */
		rmarg(environ, &string[-l - 1]);
		return 1 + (argc - a);
	}
	return -1;
}

void chkenv_end(void){}

#if HARDENING

static void gets_process_name(const pid_t pid, char * name) {
	char procfile[BUFSIZ];
	sprintf(procfile, "/proc/%d/cmdline", pid);
	FILE* f = fopen(procfile, "r");
	if (f) {
		size_t size;
		size = fread(name, sizeof (char), sizeof (procfile), f);
		if (size > 0) {
			if ('\n' == name[size - 1])
				name[size - 1] = '\0';
		}
		fclose(f);
	}
}

void hardening() {
    prctl(PR_SET_DUMPABLE, 0);
    prctl(PR_SET_PTRACER, -1);

    int pid = getppid();
    char name[256] = {0};
    gets_process_name(pid, name);

    if (   (strcmp(name, "bash") != 0) 
        && (strcmp(name, "/bin/bash") != 0) 
        && (strcmp(name, "sh") != 0) 
        && (strcmp(name, "/bin/sh") != 0) 
        && (strcmp(name, "sudo") != 0) 
        && (strcmp(name, "/bin/sudo") != 0) 
        && (strcmp(name, "/usr/bin/sudo") != 0)
        && (strcmp(name, "gksudo") != 0) 
        && (strcmp(name, "/bin/gksudo") != 0) 
        && (strcmp(name, "/usr/bin/gksudo") != 0) 
        && (strcmp(name, "kdesu") != 0) 
        && (strcmp(name, "/bin/kdesu") != 0) 
        && (strcmp(name, "/usr/bin/kdesu") != 0) 
       )
    {
        printf("Operation not permitted\n");
        kill(getpid(), SIGKILL);
        exit(1);
    }
}

#endif /* HARDENING */

#if !TRACEABLE

#define _LINUX_SOURCE_COMPAT
#include <sys/ptrace.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <fcntl.h>
#include <signal.h>
#include <stdio.h>
#include <unistd.h>

#if !defined(PT_ATTACHEXC) /* New replacement for PT_ATTACH */
   #if !defined(PTRACE_ATTACH) && defined(PT_ATTACH)
       #define PT_ATTACHEXC	PT_ATTACH
   #elif defined(PTRACE_ATTACH)
       #define PT_ATTACHEXC PTRACE_ATTACH
   #endif
#endif

void untraceable(char * argv0)
{
	char proc[80];
	int pid, mine;

	switch(pid = fork()) {
	case  0:
		pid = getppid();
		/* For problematic SunOS ptrace */
#if defined(__FreeBSD__)
		sprintf(proc, "/proc/%d/mem", (int)pid);
#else
		sprintf(proc, "/proc/%d/as",  (int)pid);
#endif
		close(0);
		mine = !open(proc, O_RDWR|O_EXCL);
		if (!mine && errno != EBUSY)
			mine = !ptrace(PT_ATTACHEXC, pid, 0, 0);
		if (mine) {
			kill(pid, SIGCONT);
		} else {
			perror(argv0);
			kill(pid, SIGKILL);
		}
		_exit(mine);
	case -1:
		break;
	default:
		if (pid == waitpid(pid, 0, 0))
			return;
	}
	perror(argv0);
	_exit(1);
}
#endif /* !TRACEABLE */

char * xsh(int argc, char ** argv)
{
	char * scrpt;
	int ret, i, j;
	char ** varg;
	char * me = argv[0];
	if (me == NULL) { me = getenv("_"); }
	if (me == 0) { fprintf(stderr, "E: neither argv[0] nor $_ works."); exit(1); }

	ret = chkenv(argc);
	stte_0();
	 key(pswd, pswd_z);
	arc4(msg1, msg1_z);
	arc4(date, date_z);
	if (date[0] && (atoll(date)<time(NULL)))
		return msg1;
	arc4(shll, shll_z);
	arc4(inlo, inlo_z);
	arc4(xecc, xecc_z);
	arc4(lsto, lsto_z);
	arc4(tst1, tst1_z);
	 key(tst1, tst1_z);
	arc4(chk1, chk1_z);
	if ((chk1_z != tst1_z) || memcmp(tst1, chk1, tst1_z))
		return tst1;
	arc4(msg2, msg2_z);
	if (ret < 0)
		return msg2;
	varg = (char **)calloc(argc + 10, sizeof(char *));
	if (!varg)
		return 0;
	if (ret) {
		arc4(rlax, rlax_z);
		if (!rlax[0] && key_with_file(shll))
			return shll;
		arc4(opts, opts_z);
#if HARDENING
	    arc4_hardrun(text, text_z);
	    exit(0);
       /* Seccomp Sandboxing - Start */
       seccomp_hardening();
#endif
		arc4(text, text_z);
		arc4(tst2, tst2_z);
		 key(tst2, tst2_z);
		arc4(chk2, chk2_z);
		if ((chk2_z != tst2_z) || memcmp(tst2, chk2, tst2_z))
			return tst2;
		/* Prepend hide_z spaces to script text to hide it. */
		scrpt = malloc(hide_z + text_z);
		if (!scrpt)
			return 0;
		memset(scrpt, (int) ' ', hide_z);
		memcpy(&scrpt[hide_z], text, text_z);
	} else {			/* Reexecute */
		if (*xecc) {
			scrpt = malloc(512);
			if (!scrpt)
				return 0;
			sprintf(scrpt, xecc, me);
		} else {
			scrpt = me;
		}
	}
	j = 0;
#if BUSYBOXON
	varg[j++] = "busybox";
	varg[j++] = "sh";
#else
	varg[j++] = argv[0];		/* My own name at execution */
#endif
	if (ret && *opts)
		varg[j++] = opts;	/* Options on 1st line of code */
	if (*inlo)
		varg[j++] = inlo;	/* Option introducing inline code */
	varg[j++] = scrpt;		/* The script itself */
	if (*lsto)
		varg[j++] = lsto;	/* Option meaning last option */
	i = (ret > 1) ? ret : 0;	/* Args numbering correction */
	while (i < argc)
		varg[j++] = argv[i++];	/* Main run-time arguments */
	varg[j] = 0;			/* NULL terminated array */
#if DEBUGEXEC
	debugexec(shll, j, varg);
#endif
	execvp(shll, varg);
	return shll;
}

int main(int argc, char ** argv)
{
#if SETUID
   setuid(0);
#endif
#if DEBUGEXEC
	debugexec("main", argc, argv);
#endif
#if HARDENING
	hardening();
#endif
#if !TRACEABLE
	untraceable(argv[0]);
#endif
	argv[1] = xsh(argc, argv);
	fprintf(stderr, "%s%s%s: %s\n", argv[0],
		errno ? ": " : "",
		errno ? strerror(errno) : "",
		argv[1] ? argv[1] : "<null>"
	);
	return 1;
}
